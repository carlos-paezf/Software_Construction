"use strict";(self.webpackChunksoftware_construction=self.webpackChunksoftware_construction||[]).push([[2450],{19:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/01-capas-clean-architecture-7dfbec46970a77aea3337becc75ed995.webp"},3135:(e,n,a)=>{a.d(n,{A:()=>s});const s=a.p+"assets/images/02-clean-architecture-185e125bfef2ef01f445c86b2a86c99c.webp"},5064:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>p,frontMatter:()=>c,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"modern_software_architecture_and_design/layers_and_dependencies_in_clean_architecture","title":"Capas y dependencias en Clean Architecture","description":"Clean Architecture es un enfoque de dise\xf1o de software propuesto por Robert C. Martin (Uncle Bob) que organiza el sistema en capas conc\xe9ntricas. Su principal objetivo es proteger la l\xf3gica de negocio de las dependencias externas, permitiendo una alta modularidad, mantenibilidad y testabilidad.","source":"@site/docs/02_modern_software_architecture_and_design/04_layers_and_dependencies_in_clean_architecture.md","sourceDirName":"02_modern_software_architecture_and_design","slug":"/modern_software_architecture_and_design/layers_and_dependencies_in_clean_architecture","permalink":"/Software_Construction/docs/modern_software_architecture_and_design/layers_and_dependencies_in_clean_architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02_modern_software_architecture_and_design/04_layers_and_dependencies_in_clean_architecture.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Principios de Clean Architecture","permalink":"/Software_Construction/docs/modern_software_architecture_and_design/clean_architecture_principles"},"next":{"title":"Arquitectura modular monol\xedtica","permalink":"/Software_Construction/docs/modern_software_architecture_and_design/monolithic_modular_architecture"}}');var r=a(4848),i=a(8453);const c={sidebar_position:4},t="Capas y dependencias en Clean Architecture",d={},o=[{value:"Capas fundamentales",id:"capas-fundamentales",level:2},{value:"Patrones de dise\xf1o involucrados",id:"patrones-de-dise\xf1o-involucrados",level:2},{value:"Variantes en la implementaci\xf3n",id:"variantes-en-la-implementaci\xf3n",level:2},{value:"Aplicaciones pr\xe1cticas",id:"aplicaciones-pr\xe1cticas",level:2},{value:"Referencias",id:"referencias",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"capas-y-dependencias-en-clean-architecture",children:"Capas y dependencias en Clean Architecture"})}),"\n",(0,r.jsxs)(n.p,{children:["Clean Architecture es un enfoque de dise\xf1o de software propuesto por Robert C. Martin (Uncle Bob) que organiza el sistema en ",(0,r.jsx)(n.strong,{children:"capas conc\xe9ntricas"}),". Su principal objetivo es ",(0,r.jsx)(n.strong,{children:"proteger la l\xf3gica de negocio"})," de las dependencias externas, permitiendo una alta ",(0,r.jsx)(n.strong,{children:"modularidad, mantenibilidad y testabilidad"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"capas-fundamentales",children:"Capas fundamentales"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Entidades"}),": Definen las entidades o modelos del negocio"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Casos de uso"}),": Se define la l\xf3gica espec\xedfica que permite ejecutar acciones concretas en el sistema."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Infraestructura"}),": Contiene la implementaci\xf3n concreta de los puertos definidos en el dominio."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Controladores"}),": Son la capa uqe conecta al usuario con el resto del sistema."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Capa de Frameworks y Herramientas"}),": Contiene el c\xf3digo que interact\xfaa con bibliotecas, frameworks y herramientas externas. Es la capa m\xe1s externa."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"En"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Capas",src:a(19).A+"",width:"720",height:"529"})}),"\n",(0,r.jsx)(n.h2,{id:"patrones-de-dise\xf1o-involucrados",children:"Patrones de dise\xf1o involucrados"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Dependency Inversion Principle (DIP)"})}),"\n",(0,r.jsx)(n.p,{children:"El principio de inversi\xf3n de dependencias, aunque no es un patr\xf3n, es una de las bases primordiales del dise\xf1o dentro del Clean Architecture."}),"\n",(0,r.jsx)(n.admonition,{type:"success",children:(0,r.jsx)(n.p,{children:"El c\xf3digo que implementa reglas de alto nivel, no deber\xeda depender de c\xf3digo que implementa detalles de bajo nivel. Por el contrario, los detalles deben depender de las reglas."})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Level",src:a(3135).A+"",width:"720",height:"636"})}),"\n",(0,r.jsx)(n.p,{children:"Usando interfaces e inyecci\xf3n de dependencias se logra aplicar este concepto dentro del proyecto."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Inversion of Control (IoC)"})}),"\n",(0,r.jsx)(n.p,{children:"Es una t\xe9cnica donde el control sobre la creaci\xf3n y manejo de objetos se delega a un contenedor de IoC. Este principio es aplicado con la inyecci\xf3n de dependencias, lo cual es esencial para mantener la independencia entre capas."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Dependency Injection (Inyecci\xf3n de Dependencias)"})}),"\n",(0,r.jsx)(n.p,{children:"Es un patr\xf3n que se utiliza para proporcionar las dependencias requeridas por una clase desde el exterior, en lugar de crearlas internamente. Esto ayuda a desacoplar las clases y facilita el reemplazo de las implementaciones sin modificar el c\xf3digo existente."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Separation of Concerns (SoC) (Separaci\xf3n de Responsabilidades)"})}),"\n",(0,r.jsx)(n.p,{children:"No es un patr\xf3n espec\xedfico, sino un principio de dise\xf1o que busca dividir un sistema en componentes que tengan responsabilidades distintas y bien definidas. Esto es esencial para mantener una arquitectura limpia."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Repository Pattern (Patr\xf3n Repositorio)"})}),"\n",(0,r.jsx)(n.p,{children:"Es un patr\xf3n que se utiliza para encapsular el acceso a la capa de persistencia de datos. En la Clean Architecture, se usa para separar el acceso a la base de datos u otras fuentes de datos, permitiendo que la capa de negocio no dependa directamente de la infraestructura de datos."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Case Interactors / Interactor Pattern (Patr\xf3n Interactor)"})}),"\n",(0,r.jsx)(n.p,{children:"En la Clean Architecture, los casos de uso o Use Cases representan las acciones espec\xedficas que puede realizar el sistema. Los interactors son clases que encapsulan la l\xf3gica de negocio de cada caso de uso y se comunican con las entidades y los repositorios."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Presenter Pattern (Patr\xf3n Presentador)"})}),"\n",(0,r.jsx)(n.p,{children:"Es un patr\xf3n utilizado para separar la l\xf3gica de presentaci\xf3n de la interfaz de usuario de la l\xf3gica de negocio subyacente. En la Clean Architecture, el presentador se encarga de transformar los datos del caso de uso en una forma adecuada para ser presentada en la interfaz de usuario."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Mapper Pattern (Patr\xf3n Mapeador)"})}),"\n",(0,r.jsx)(n.p,{children:"En la Clean Architecture, se utilizan mapeadores para convertir datos entre las diferentes capas y formatos. Por ejemplo, para transformar objetos de la capa de datos en objetos de la capa de dominio y viceversa."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"variantes-en-la-implementaci\xf3n",children:"Variantes en la implementaci\xf3n"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arquitectura Hexagonal (Hexagonal Architecture)"}),": Esta arquitectura es una variante de la Clean Architecture que enfatiza la separaci\xf3n de responsabilidades. Ambas arquitecturas comparten principios y objetivos similares. La diferencia principal radica en la forma de representar esa separaci\xf3n y la terminolog\xeda utilizada. En la arquitectura hexagonal, se destacan los conceptos de puertos y adaptadores, que definen las interfaces de comunicaci\xf3n y sus implementaciones."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arquitectura Cebolla (Onion Architecture)"}),": Es otra variante de la Clean Architecture que se enfoca en organizar el c\xf3digo en capas conc\xe9ntricas, donde el n\xfacleo del sistema se encuentra en el centro y las capas externas representan diferentes niveles de abstracci\xf3n y detalles de implementaci\xf3n."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"aplicaciones-pr\xe1cticas",children:"Aplicaciones pr\xe1cticas"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Backend desacoplado:"})," puedes cambiar NestJS por Express o Fastify sin tocar l\xf3gica de negocio."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Frontend desacoplado:"})," puedes migrar Angular a React y seguir usando los mismos contratos y casos de uso."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pruebas m\xe1s sencillas:"})," puedes probar ",(0,r.jsx)(n.code,{children:"CreateStudentUseCase"})," sin HTTP, sin base de datos."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Escalabilidad clara:"})," puedes a\xf1adir nuevas fuentes de datos (por ejemplo, GraphQL o sockets) sin duplicar l\xf3gica."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"referencias",children:"Referencias"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Martin, R. C. (2018). Clean Architecture: A Craftsman's Guide to Software Structure and Design. Prentice Hall."}),"\n",(0,r.jsx)(n.li,{children:"Brown, S. (2019). Software Architecture for Developers (2nd ed.). Leanpub."}),"\n",(0,r.jsx)(n.li,{children:"Fowler, M. (2004). Patterns of Enterprise Application Architecture. Addison-Wesley."}),"\n",(0,r.jsxs)(n.li,{children:["Diego Coder. (2023). ",(0,r.jsx)(n.a,{href:"https://medium.com/@diego.coder/introducci%C3%B3n-a-las-clean-architectures-723fe9fe17fa",children:"Introducci\xf3n a las \u201cClean Architectures\u201d"}),". Medium."]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://angular.io/guide/architecture",children:"Angular Docs - Architecture Overview."})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.nestjs.com",children:"NestJS Core Team. (2024). NestJS Docs."})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>c,x:()=>t});var s=a(6540);const r={},i=s.createContext(r);function c(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);